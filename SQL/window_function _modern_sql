window_function _modern_sql

this will perform a calucluation across set of rows that related to current row
wihout colapsoing row the way GROUP BY   does

it let you look at rows while still keeping each row visible

You’re standing at one window looking out at others.
You see all rows, but you calculate something relative to your position.

to avoid lot of sub queries we prefer nested subqueries
    ---    

<function_name> over (parition by <grouping> order by <ordering>)

FUNCTION()	Rank, Sum, Count, etc
PARTITION BY	How to group (like GROUP BY) but without collapsing rows
ORDER BY	Defines order of calculation

RANK()	Gives same rank for ties, skips next rank
DENSE_RANK()	Gives same rank for ties, no gaps
ROW_NUMBER()	Gives unique sequence number per row
SUM() OVER	Running total
AVG() OVER	Moving average
---------------------------

Find highest salary per department (classic interview)

select emp_id, emp_name, dept_id, salary
from ( select e.*,
          DENSE_RANK OVER(PARTITION BY dept_id ORDER BY salary DESC) AS rnk
  from EMPLOYEE e) x
WHERE rnk =1;



Q15

Use ROW_NUMBER() to pick only one (any one) top salary employee per department.

//(ROW_NUMBER doesn't handle ties; DENSE_RANK does)

select emp_name, salary
from ( select e.*, ROW_NUMBER() OVER(PARTITION BY dept_id ORDER BY salary DESC) AS r
from employee e
) X
where r =1
----------------------------------------------------------
Ntile(N) : this divide rows into n equls bucket on order

like splitting ranekd rows into group

for EG:

select emp_name, salary, NTILE(4) OVER (ORDER BY salary DESC) AS salary _group
from employee;

90k, 88k, 85k, 82k, 75k, 70k, 68k, 60k

| salary | group |
| ------ | ----- |
| 90k    | 1     |
| 88k    | 1     |
| 85k    | 2     |
| 82k    | 2     |
| 75k    | 3     |
| 70k    | 3     |
| 68k    | 4     |
| 60k    | 4     |
------------------
helpfuliin employee rating tier


2. LEAD()

comparing a row to the row below it

SELECT emp_name, salary,
       LEAD(salary) OVER (ORDER BY salary DESC) AS next_salary
FROM employee;

if salaris are
70k, 65k, 50k

70k | next = 65k
65k | next = 50k
50k | next = NULL
used for findning salarie difference

3) LAG()

Look backward to previous row’s value.

SELECT emp_name, salary,
       LAG(salary) OVER (ORDER BY salary DESC) AS previous_salary
FROM employee;

70k | previous = NULL
65k | previous = 70k
50k | previous = 65k

for EG:

With difference calculation:
SELECT emp_name, salary,
       salary - LAG(salary) OVER (ORDER BY salary DESC) AS salary_diff
FROM employee;

Function	Memory Hook	Explanation
NTILE(N)	“Divide into N groups”	Splits ordered rows into roughly equal buckets
LEAD()	“Look ahead”	Gets value from the next row
LAG()	“Look back”	Gets value from the previous row


Q17)
Use LAG() to show how much an employee’s salary increased compared to the previous highest salary.

select emp_name, salary - LAG(SALARY) OVER(order by salary desc) as ps
from employee

emp_name	salary	salary_diff
Highest salary person	90,000	NULL (no one above)
Next person	80,000	80,000 - 90,000 = -10,000
Next	75,000	75,000 - 80,000 = -5,000


Q18) Use LEAD() to show the next employee's salary and the difference.

Expected columns:

emp_name | salary | next_salary | diff_with_next

select emp_name, LEAD(salary) over (order by salary)as next-sal from employee


emp_name	salary	next_salary	diff_with_next
A	90000	85000	5000
B	85000	78000	7000
C	78000	NULL	NULL

So your interview line becomes:

“LEAD compares the current row to the next row. Here I used it to calculate how much more an employee earns than the next lower-paid employee.”
