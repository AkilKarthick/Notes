REST APIs = Representational state transfer
üìåit is an Architectural style where:
	data is exposedd as resoure
	communicatio happen over hTTP request/response
	use standart HTTP methods

RESt api flow ( controller -> service -> repository )

	client sends an http request, 
	the controller handles it, 
	interacting with you businesss logic present on service layer
	and sends a response back

HTTP methods:
	GET	-	fetch data
	POST-	create data
	PUT-	update full resoure
	PATCH-	partical update
	DELTE-	remove data

üé§ Common interview trap
PUT vs PATCH
	PUT replaces the entire resource, PATCH updates only specific fields

3Ô∏è‚É£ HTTP STATUS CODES (üî• VERY IMPORTANT)
we always return meaninful HTTP status code to make APIs 
	200- succes
	201- created
	204- no content
	400- bad request
	404- nof found
	500 internal server error
{still more to explore here) 

üî• VERY IMPORTANT implemtatio part:

we need to use üìå-spring boot starter web-  dependice on pom.xml file to use all facilities required  for rest api development
 i'm able to get these features:

	spring MVC and web - fro web develpment
	embedded server ( jetty or tomcat
	RESTful apis using lilbraties like jackson- for json processing
	auto configurations realted components like Dispatcher serverlet, static resoure handling ec
	springboot starter validation for input validation

use @RestController on class level to make rest controller
while serilaize the response object to json

@RestController = @Controller + @ResponseBody
	@Controller - return view (HTML)
	@RestController -return JSON (REST)
return java objects from your controller method, spring boot converts these to JSON automatically

eg: @GetMapping("/path")  to define endpoints

public ResponseEntity<UserDTO> getUser(Long id){
	UserDTO dto= userService.getUserById(id);
	return ResonesEntity.ok(dto)
}
---------------------------------------------------------------------------------------
üîπAnnotations:

1.@RestController
to mark a class a REST controller
combination of @controller & @responseBody annotation
automatically serialize return object to json or xml response

2.@RequestMapping("/api")

maps http request to handler method. can be usedin class or method level
we provide the base URL for all the method /api


3.@GetMapping  or @RequestMappig(method = RequestMethod.GET)
@PostMapping
@PutMapping
@DeleteMapping
@PatchMapping - partial update via http pattch

 @RequestBody annotation maps the HttpRequest body to a transfer or domain object,
 enabling automatic deserialization of the inbound HttpRequest body onto a Java object.

4.@RequestParam - binds HTTP query parameter or form data to method parameters

4.@RequestBody - used to accept JSON input
5.@PathVariable - binds URI template variables(in the url path) to method parameter

6.@ResponseBody - indicate that the return value of the method should be used as the response body  if you use @Controller means no need to use this

7.@ResponseStatus - sets the HTTP status code for the response(204 for delete)

8.@CrossOrgin - enable cros cross orgin reouse sharing on controller or method level
		on specified endpoint
----------------------------------------------------


eg for all the above annotations

// Mark the class as a REST controller
@RestController

// Map all URLs under "/api"
@RequestMapping("/api")
public class ApiController {

// Maps GET requests for /api/greet?name=User
    @GetMapping("/greet")
    public String greet(@RequestParam(defaultValue = "World") String name) {
        return "Hello, " + name;
    }

--------------------------

// Create new product
    @PostMapping
    public Product createProduct(@RequestBody Product product) {
        return productService.saveProduct(product);
    }

@RequestBody::
Deserialization of JSON: When a client (like a frontend app or Postman) sends a POST request with JSON data, @RequestBody tells Spring to convert that JSON into a Java object‚Äîin this case, a Product.


Let‚Äôs say the client sends this JSON:

json
{
  "name": "Gaming Mouse",
  "price": 1499.99
}
With @RequestBody, Spring will automatically convert this into:

java
Product product = new Product("Gaming Mouse", 1499.99);

Then productService.saveProduct(product) can persist it however you‚Äôve defined.


so what is ResoonseEntity used?

a powerfull helper class in springfm, that represne the entire HTTP response including

HTTP status code (like 200 OK, 400 Bad Request)
HTTP headers (like Content-Type)
Response body (usually JSON or XML content)


You can specify exact HTTP status codes for each API response, instead of relying on default behaviors.
You can define the body, or send no content (204 No Content), depending on the requirement.
In exception handlers, ResponseEntity lets you send error messages and status codes clearly to clients.




