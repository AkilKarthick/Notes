Dependency inject interview questions





agenda==============================================================
1.what is constructor vs field vs setter injection? in springboot
2.how to avoid bean creation failure in dependency injection
3.what is @qualifier & @primay annotations
=====================================================================


1.what is constructor vs field vs setter injection? in springboot


constructor injection:

dependencies are passed via constructor, so the object is fully initialized when created
it is the safest & most preferred way

@Component
public class Service {
    private final Repository repo;

    @Autowired
    public Service(Repository repo) {
//initialize During object creation
//Dependenci are passed explicitly throughconstructor.
        this.repo = repo;  
    }
}Guarantees that the dependencies are fully initialized during object creation
Makes the class easier to unit test, as you can create instances with mock dependencies without needing Spring context

-------------------------------------------------------
Field Injection: Spring injects dependencies directly into fields using reflection. Itâ€™s concise but not good for testing and hides dependencies.

@Component
public class Service {
    @Autowired
    private Repository repo;
}

-------------------------------
Setter Injection: Dependencies are injected through setter methods, allowing flexibility and optional dependencies but can lead to inconsistent object states.

Setter Injection: Use for optional dependencies or those that may change, like feature toggles or caches.

@Component
public class Service {
    private Repository repo;

    @Autowired
    public void setRepository(Repository repo) {
        this.repo = repo;
    }
}

---------------------p------qualifier & primary annotations-----------------------------------------------------------------

@Qualifier -
Explicitly specifies which bean to inject
to resolve conflicts when multiple beans exist, specifying exactly which to use.


@Component("emailService")
public class EmailService implements MessageService {
    // ...
}

@Component("smsService")
public class SMSService implements MessageService {
    // ...
}

@Component
public class Notification {
    private MessageService messageService;

    @Autowired
    @Qualifier("smsService")  // Specifies exactly which bean to inject
    public void setMessageService(MessageService messageService) {
        this.messageService = messageService;
    }
}

-----------------------------------------------------------------------------------------------

@Primary - Marks one bean as the default choice
to mark a bean as the default choice to be injected automatically when no qualifier is given.

@Component
@Primary
public class DefaultMessageService implements MessageService {
    // This will be injected if no @Qualifier is specified
}

@Component
public class OtherMessageService implements MessageService {
    // Non-primary bean
}

@Component
public class Notification {

    @Autowired
    private MessageService messageService; // Injects DefaultMessageService by default
}
----------------

When both @Qualifier and @Primary annotations are used in Spring for dependency injection, @Qualifier takes precedence over @Primary


===============================================================================================


how to avoid bean creation failure in dependency injection

@Autowired(required = false) //to make injection optional.
private SomeService someService;
--------------

This removes the need for external server installation and simplifies workflows
It uses TomcatServletWebServerFactory internally to manage the embedded server lifecycle.


