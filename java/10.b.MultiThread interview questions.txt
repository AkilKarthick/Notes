MultiThread interview questions


1.What is Multithreading in Java?

allows a pgm to run multiple threads simultaneousely with in single process
helps perform multiple task in parallel ,leading to better CPU utilization and faster program execution

a Thread - smllaest unit of exection or a light weight sub process

MulitpThread - allows multiple thread to run concurrently. sharing the same memory but execyting independly

life cycle of thread===========

new - thread is created but not yet started
runnable - thread is ready to run and waiting for cpu scheduling
Running - thread is actually executing its task
waiting - Thread waits for another thread action like notification
Timed waiting - thread wait for a specific period eg thread.sleep(1000)
Terminated - thread finish execution & stopped

---------------------------------------------------------------------
2. what is synchronization in java and synchronized key word in java?


synchronization in java ensure that only one thread can access a shared resource at a time
preventing errors due to concurrent modification

Synchronization in Java is a mechanism to control the access of multiple threads to shared resources or critical sections of code, ensuring that only one thread can execute a synchronized block or method at a time. This prevents race conditions and data inconsistency when multiple threads try to modify shared data concurrently.

Synchronized keyword: marks method or block to make them thread safe -by allowing only one thread to execute them at once

When a thread enters a synchronized method/block, it acquires a lock (monitor) on the object, and other threads must wait until the lock is released.

for eg:

in this eg: two or more thread calling increment() or getCount() shared methods 
one at a time to avoid erros inconsisten values

When a thread enters a synchronized method/block, it acquires a lock (monitor) on the object, and other threads must wait until the lock is released.

It ensures mutual exclusion and thread-safe access to shared resources

class Counter {
    private int count = 0;

    public synchronized void increment() {
        count++;
    }

    public synchronized int getCount() {
        return count;
    }
}
-------------------------------

difference between wait() & sleep()?

wait() - is used to pause a thread untl another thread notifies it, and it releasese the lock so other thread can access the synchronized block

sleep() - pause the current thread for a fixed time bt keeps holding any lock it has

synchronized (obj) {
    obj.wait();  // waits and releases lock
}

Thread.sleep(1000);  // sleeps but keeps lock
----------------------------------------------------

what is volatile keyword?

if we use this on a variable means. any read & write happedn to that variable is always done directly from main memory not from thread local cpu cachce. 
this ensure that changes made by one thread to the variable are immediately visible to all other threads
volatile can only be applied to variables, not methods or classes
Declaring a variable as volatile guarantees visibility of changes across threads

Without volatile, different threads may have cached copies of the variable, leading to inconsistent or stale value


public class Example {
    private volatile boolean flag = false;

    public void setFlagTrue() {
        flag = true;  // Changes visible immediately to other threads
    }

    public boolean checkFlag() {
        return flag;  // Always reads current value from main memory
    }
}
---------------------------------

what is thread local?

variables are typically declared as private & static fields
it provide each thread to have its own copy of a variable preventing conflicts
it is like giving each thread its own workspace where they can store and modify variables indpendntly

--------------------------------
what is deadlock in java? and how can te be avoided?

a situation in multithread where two or more threads are blocked forever.
each waiting for a lock held by the other threads, this cause the thread to wait forever, like freze or hand can happedn , none of the threads can proceed.

how to avoid means

1.keep synchronized block only for lock critical sections
2.If the lock is already held by another thread, tryLock() returns false immediately instead of blocking.
3.instead of regular lock() we can use trylock() with
use trylock() with timeoout. allows thread to get lock or backoff instead of waiting forever
4.alternative actions like retrying later, logging, or skipping the operation
(tryLock(timeout, TimeUnit))-lets threads wait for a limited time before giving up
6.avoid nestedlocks
--------------------------------

Thread

extends Thread class
create thread object and call start() method

class MyThread extends Thread {
    public void run() {
        System.out.println("Thread running");
    }
}
MyThread t = new MyThread();
t.start();
-------------------------------------------------------
difference between Runnable & callable ?

Runnable and Callable are two interfaces in Java used for defining tasks that can be executed by threads

-------------
runnable
-------------
For EG::

class MyRunnable implements Runnable {
  public void run() { //does not return a result.
    System.out.println("Task running");
  }

Represents a task that can be run by a thread but does not return a result.
Has a single method run() which contains the code to execute.
Can’t throw checked exceptions.
Used when you want to run code asynchronously but don’t need any result back.
Can be run by creating a Thread

---------
Callable
---------
For EG::

class MyCallable implements Callable<String> {
  public String call() throws Exception {
    return "Result";
  }

Represents a task that can be run by a thread and returns a result.
call() which returns a result and can throw checked exceptions.
Used when you want to run code asynchronously and need a result or can handle exceptions.

---------------------------------------------
synchronized method and synchoronzed block diffference?

Synchronized method locks the whole method for one thread at a time. This is simple but may cause performance overhead if only part of the method is critical.

Synchronized block lets you lock just a piece of code inside a method, improving performance by reducing the locked area and allowing other threads to execute non-critical code concurrently.


I haven’t directly created threads, but Spring Boot internally uses multithreading to handle concurrent requests, and I understand thread-safety concepts





