Thread: a light weight process that executes a task

	a lightweight process called thread & it allow different part of a programs to execute simulatenously
	
creating a thread in java 
	-is by extending ğŸ’¡ Thread class or by implementing Runnable ğŸ’¡ interface

1.Thread class -- Extend Thread when no other class inheritance is needed
2.Runnable interface --Implement Runnable when the class already extends another class (preferred). - java support only single inheritance that;s why

in project we always prefer Runnable or ExecturService for better design and scalability

------------------------
ğŸ”¥Extending Thread class:
	poor design, can't extend another class, Tight coupling

eg1:

class Mythread extends Thread{

	public void run(){
	System.out.println("Thread Started Running...");
	}
}

public class Demo {
	public static void main(string[] args){
	MyThread t1 = new Mythread();
	t1.start(); //start() will internally call run() method
	}
}
--------------------------------------------------
ğŸ”¥ implementing runnable interface // preferred ay
		Better design, Support inheritance & loose coupling

class MyRunnable implements Runnable{
	public void run(){
	System.out.println("Thread Started Running...");
	}

}

public class Demo {
	public static void main(string[] args){

//creating an instance of the class MyRunnable
	MyRunnable mr = new MyRunnable();
	Thread t1 = new thread(mr);

	t1.start(); //start() will internally call run() method
	}
}


ğŸ”¹1. can we call run() directly instead of start() ? what happend?

YES you can but no new thread is created!

Thread t = new Thread(()->System.out.println(""))

	t.run(); // runs in main method
	t.start();// runs in new thread

ğŸ”¹Interview line:
	â€œCalling run() executes the task in the same thread, while start() spawns a new thread and invokes run() internally.â€


ğŸ”¹.2.what happend if you call start() twice?
	
	Thread t = new Thread(() -> {});
	t.start();
	t.start(); // âŒ  IllegalThreadStateException

ğŸ”¹bcz thread lifecyel is one time use only
Thread are never resued - instrea we use Thread Pool (Executor Service)

ğŸ”¥ 3. Can we override start() method?
yes but override start() prevents JVM from creating a new thread!

ğŸ”¥ 4. Difference between sleep() and wait()? (Very common ğŸ”¥)

sleep()
	belong to Thread class
	lock is not released
	no need for synchronized
	Thread.sleep(10000); //used for delaying logic

wait()
	beling to object class
	locked released ? yes
	need synchronized
	obj.wait(); // release lock

ğŸ”¥ 5. Why wait() is inside synchronized block?  doubt

ğŸ”¥ 6. What is Thread Deadlock? Give real example.
	both threads wait forever!
production fix: avoid nexted synchroniztion, timeoutlocks and lock ordering

ğŸ”¥ 7. Difference between volatile and synchronized? (Tricky ğŸ”¥)

volatitl gurantess visibility, not atomicity
no locking
faster

Volatilt boolean flag = true;

Synchronized: gurante visibility and atomicity
locking
slower

ğŸ”¥ 8. Is ++ thread-safe? Why?

ğŸ”¥ 9. Difference between Runnable and Callable? (Often tricky)

Runnable
	No return 
	no expcetion
	run()

callable
	return value
	can throw checekd exception
	call()

Callable<Integer> c =()-?10;
used in executorServices

ğŸ”¥ 10. Can two threads call the same synchronized method?



Thread Lifecycle (VERY IMPORTANT ğŸ”¥)

states:

	new
	Runnable
	Running
	Waiting/Blocked
	Terminateed








single thread - one task at a time
============================================================
multiple Thread: 
---------------
running multiple thread simultaneously to perform different task at the same time
which improve performance and cpu utilizations,  
each thread run independently but shares the same memory space
allows concurrent execution of task to improve perfromance

used when : handling multple user request, fikle processing
interview hint : improves appplications responsiveness


class MyThread extends Thread {
    String task;

    MyThread(String task) {
        this.task = task;
    }

    public void run() {
        for (int i = 1; i <= 5; i++) {
            System.out.println(task + " : " + i);
            try {
                Thread.sleep(1000); // Pause for 1 second
            } catch (InterruptedException e) {
                System.out.println(e.getMessage());
            }
        }
    }
}

public class MultiThreadDemo {
    public static void main(String[] args) {
        MyThread t1 = new MyThread("Cut the ticket");
        MyThread t2 = new MyThread("Show your seat number");
        
        t1.start(); // Start first thread
        t2.start(); // Start second thread
    }
}

output:
Cut the ticket : 1
Show your seat number : 1
Cut the ticket : 2
Show your seat number : 2
...
Cut the ticket : 5
Show your seat number : 5


Two threads (t1 and t2) run concurrently.

Each prints its respective task with a delay of 1 second.

Threads run independently, so their output interleaves, showing multitasking.

---------------------------------
what is synchronization

	it ensure only one thread executes a critical method/section at a time
	prevents race condtion and allowoing one thread at a time

only 1 thread at a time can enter this method!
	synchronized void increment() {
	    count++;
	}

what is thread pool?

	manage a fixed number of reusable threads to execute task concuretnly, reducing overhead of thread creation and destruction
	
	wait() // relase lock and wait for notification
	sleep() // doesn't release any lock and pause the thread for a specific time
	
	start() - create a new threa | multiple times means IllegalThreadStateException  throws

hwo thread communicate with each other ?

	through inter- thread communication method wait(), notify(), and notifyall() using inside 	synchronized blokc to coordinate execution

Thread lifecycle: / thread can go through multiple states during executions

new
Runnable
Running
Waiting/Blocked
Terminated

I havenâ€™t directly created threads, but Spring Boot internally uses multithreading to handle concurrent requests, and I understand thread-safety concepts


States:
	New
	Runnable
	Running
	Waiting / Blocked
	Terminated
ğŸ“Œ Interview line:
â€œA thread goes through multiple states during execution.â€


	




