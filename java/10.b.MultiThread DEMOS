MultiThread demo eg1: using Thread class
1. using Thread class:


class MultiThread extends Thread{

  private String name;

  public MultiThread(String name){
    this.name=name;
  }

@Override
public void run(){
    for(int i=0; i<=5; i++){
      System.out.println(name + ":" +i);
    try{
        Thread.sleep(10000);s
    }catch(InterruptedException e){}
    }
    }
}

}

public class Main{
  public static void main(String[] args){

        MultiThread t1 = new MultiThread("thread-1");
        MultiThread t2 = new MultiThread("thread-2");

      t1.start();
      t2.start(); //both run concurrently
  }
}
--------------------------------------------------------

Runnable Interface:
-------------------
class Task implements Runnable{

@Overrid
public void run(){
    for(int i=1; i<=3; i++){
    System.out.println("task in " + Thread.currentThread().getName())+":"+i); }
}
}

public class Main{
  public static void main(String[] args){
      Thread t1 = new Thread(new Task(), "workder-1")
      Thread t2 = new Thread(new Task(), "workder-2")
      t1.start();
      t2.start();
  }
}
--------------------------------------------------------
from java 5 onwardss we have this Executor Framwork,
this will manage thread execution
it will help us to submit task without manually creating or controllling thread
framework handles scheduling and execution!

we have Executor interface, ExecutorService interface
Threadpoolexecutor class & AbstractExecytorSerivce class


Demo:

class Task implement Runnable{
  private String name;
    public Task(String name) { this.name = name; }

public void run() {
  for(int i = 1; i <= 3; i++) {
            System.out.println(name + ": " + i + " on " + Thread.currentThread().getName());
            try { Thread.sleep(500); } catch(InterruptedException e) {}
        } }}

public class Main(){
  public static void main(String[] args){
      ExecutorService executor =Executos.newFixedThreadPool(2); // creates exactly 2 reusable worker threads
       
        executor.submit(new Task("Task-1")); //Thread-1 picks it up immediatel
        executor.submit(new Task("Task-2")); //Thread-2 picks it up immediatel
        executor.submit(new Task("Task-3"));  //  Both threads busy, so Task-3 goes to internal queue

        executor.shutdown(); //prevent new tasks; await terminations
  }
}


Use java ExecutorService to manage multiple threads efficiently via thread pools, avoid manual 
Thread creation.

