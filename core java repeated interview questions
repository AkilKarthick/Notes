
1.what is java main() method?
      when we execute our java pgm the jvm will looks for main method to begin 
      and only one main method
      public static void main(String[] args)
      
      a. String[] args
         a parameter extracting values from the command line in string format
       String[] args = {"1","2"}; these stored in args[0], args[1]
      later be stored in args array
----------------------------------
2. static keyword? in main method?
      to make it as globally access across the class     
       
A. static variable - a public access eg publlic summing pool
a.class level variable, shared among all the instance of the class
there is only one copy of static variable in memory regardlerss of how
many object of the class are created.
b.can be accessed without creating an instance of the object

        B. static method - are like shared serverice eg secuity gurad 
                        any body can access
They can be called using the class name directly.

for EG:

                  public class MathUtils{
                        //static method
                        public static int addition(int a, int b){
                              return a+b;
                        }
                  //non static method
                        public int multiplicaiton(int a, int b){
                              return a*b;
                        }
                        public static void main(String[] args){
                        //calling static
                        mathUtils.addition(1,2);
                        //calling non static
                        mathUtils m = new MathUtils();
                        m.multiplication(1,3);
                        }
                  }
d.Static class at class level??
      A class can be made static only if it is a nested class.
      We cannot declare a top-level class with a static modifier but can declare nested classes as static.
      Such types of classes are called Nested static classes


--------------------------------
3.what is abstract class in java?

class are declared using the "abstract" keyword
abstract method contain abstract method ie method without body/implementaiton
implemented by subclass
they can alos have concrete methods (method with a body)

            
abstract class shape {
              public abstrat void draw();
              public void erase   // a concrete method ie non abstract method
               System.out.println("a"); 
               }
            }
            if a subc/ child clas inhert  the shape class
            class circle extends Shape{
   // the abstract method must be defined here 
               @Override
               public void draw(){
                   System.out.println(drawing a cirvle);
               }
      }
---------------------interview qustions about abstract class??
a. can a abstract class have a constructo?
      yes, we can have but
      Although you cannot instantiate an abstract class directly,
      its constructor can be called when a subclass is instantiated.

b.can a abstract class implement an interface?
      yes abstract class can implements an interface
 If the abstract class does not provide implementations 
for all the interface methods, it remains abstract and must be
extended by a subclass that provides the remaining method implementations12.

d.Can an abstract class have static methods?
      yes

c.What happens if a subclass does not implement all abstract methods of its superclass?

If a subclass does not implement all the abstract methods of its 
superclass, the subclass must be declared as abstract. 
This means that the subclass itself cannot be instantiated and
must be extended by another class that provides implementations 
for the remaining abstract methods.

------------------------
4.what is an interface?

   Here every method is by default abstract method
   interface are used to solve the problem of multiple inhertance in java
   variables in an interface are public, static, and final by default
-------------------------
5.what is package in java?

a.buit in package - predefined classes and interface like java.util etc 
b.user defined package - to keet our poject structured & manageble
                         to  organized the code 
-------------------------------------------
5.what is the used of this keyword in java?

a.Accessing instance variables:
to refer the current instance (When a local variable within a method has the same name as an instance variable)
eg:
public class Example{
      int x;
public Example(int x){
      this.x = x;
}}
b.this to call another constructor from within a constructor
c.call the parameterized construcot
eg: 
public class Example{
      int x;
      int y;
      public Example(){
            this(1,2);//call the parametirzed consttructo
      }
      public Example(x,y){
            this.x =x;
            this.y =y
      }}
also used to call another constructor within the same class
d.return and pass the current object
public classs eg{
      eg getObject(){
            return this; //return the current object
      }
}
-----------------------
6.constructor in java?
      when you want to initializes the value that are declared in the class
      it doesn't have a return type & always named as the class name
      automatically called when an object is created using the "new" keyword
     
types
      a.default  construcotr eg: 0 for numeric types, null for objects
      b.parameterized constructor

interview queestions"

a.can a constructor be private?
yes it can be, used in the singleton design pattern to restrict
the instantiatino of a class to one objct
to control object creation
b. what is constructor overloading?
process of defining multple constructo in a class
c. what is constructor chaining?
process of calling one construcor from another constructor with in the
same class or from a sub class
using this() or super()
d. can a construcor be static?
no , bcz static method belongs to the class itself and are 
not associated with any instance
e.What happens if you don’t define a constructor in a class?
java provide default constuctor
f. can a construcot throw an exception?
yes 
public class Example{
      public Example() throws Exception{
      }
}
g. role of super() keyword in constructor?
to call the constructor or super class
it must be the first element in the superclass

eg:  
public class Animal{
      public class Animal() {
            System.out.println("Animal constru");
      }
}
public class Dog extends Animal{
      public Dog(){
      super(); // calls tanimal constructor
      System.out.println("Dog construcor called");
      }
}
---------------------------------------------------------------
7.how is method overloading is different from method overriding?

        come's under polymorphism oops concept
      a.method overloading -
             creating multiple methods with the same name 
             but different parameters within a class.determined at compile time
            return type may be differtn      
            cmpile time polymorphism
            
      b.method overriding-
         same methodname, and same parameters but implmented in subclass, runtime determination.
         subclasses providing their own implementation of inherited methods from the parent class
            return type must be same
            run time polymorphism

a.method overriding: specific implementation of a method already
      defined in its superclass . same name, return type and parameter list
      also method cannot be static superclass
      method cannot be final or private in the super class
b.can you override static method in java?
      no static method cannot be overriden, we can hide the method
known as method hidding, cannot be overridden by hidden 
for EG:
class Parent{
      //static method in superclass
      static void display(){
      System.out.println("static methi in parent class");
      }
class child extends Parent{
      //static method in the subclass
      static void display(){
            System.out.println("static method in child class");
      }
}
public class Main {
      public static void main(String[} args){
            Parent parent = new Parent();
            Parent child =  new Parent();
      parent.display(); // static methoid in parent class
      child.display(); //static methid in parent class (method hidding)
if we call uhsing class name means 
//static method in child class return
      }
}
}
----------------------------------------------------------
8.Explain the different between final & finally keyword? and finalize() method?

final--keyword
   in variable- once assigned their value cannot be changed
   in method- which cannot be overriden by sub class
   in class- cannot be subclassed

finally ? // whatever happen this finally block will executed
we can use finally without catch block

eg 
         try{
            int sum = 10/0;
            System.out.println(sum);
         }catch(ArithmeticException e){
            e.printStackTrace();
         }finally{
         System.out.println("this will be executed regardless")
         }
c. finalize() : a method called by garbage collector before an 
object is destroyed. used to perform clean up operations
before the object is garbaged collected

-------------------------------------------------------
9.what are java collections and why are they importatnt?

----java collections----------------
to store the data in more efficient way
it is a framework procide several types of colletions
data structures. They are used to store, manipulate and retrieve aggregate data.

Advantages 
      can grow or shrink dynamically
      built in algorith for sorting & searching
      addition and deletion of evelemt in a given position is easier
below interface's
      List- Ordered collection that allows duplicate elements.
            Access elements by their index   //ArrayList, LinkedList etc
      Set - Unordered collection 
            that does not allow duplicate elements. //HashSet, LinkedHashSet, TreeSet
      Map- stored key-value and each key should be uniquec
           //HashMap, LinkedHashMap, TreeMap, Hashtable
      Queue- ordered collection that follows fifo or priority based ordering principle

----------------------choose the right option-----------

      ArrayList: efficietn for Random access
                  Use for fast access to elements by index. 
                  time consueing bcz of bit shiffiting
      LinkedList: Use for frequent insertions and deletions.
                  no shifting is required bcz of dobule linked implentation      
            for frequent acess and random access linked list is not so 
            suitable
            
      Vector: for synchronized and thread safe
             when we need a thread safe collection
            it is synchronzed to ensure that one can access at atime      
            slower than array list
            multiple thread case vector is more suitable
vectors are bit outdated now

            
            

      HashSet: Use for fast membership testing (checking if an element exists).
               stored in a hashtable, no order is maintained
                  it accept null values
      TreeSet: Use for storing elements in a sorted order.
      LinkedHasSet: for natural order

      HashMap: Use for fast key-value lookups.
                  hashmap acceps one null in key and n number of null in value
                  is not synchronized internally and hence it is not thread safe
      concureentHashMap - is internally synchronized & hence it is thread safe
                        dosen;t allow a single null values
      LinkedHashMap: Use for maintaining insertion order of elements.
      TreeMap: Use for storing elements in a sorted order based on keys.

hashtable: if we used multiple thread ie synchronized better to used hash table
-----------------------------------------------------------

   List<Integer> student = new ArrayList<>();
   student.add(1);
   student.add(1);
   student.add(2);
   student.add(2);
   for(integer x : student) System.out.println(x);

everything get printed here 1 1 2 2
list allows duplicate values

//HashSet

   Set<Integer> student = new HashSet<>();
   student.add(1);
   student.add(1);
   student.add(2);
   student.add(2);
   for(Integer x: student)Systtem.out.println(x);

here in set, only 1 and 2 get printed bcz of unique value get stored in set

//HashMap

Map<String, Integer> students = new HashMap<>();
student.put("alice",1);
student.put("alice",1);
student.put("alice",2);
student.put("alice",2);
for( Map.Entry<String,Integer> entry:students.entrySet()){
System.out.println(entry.getKey() + " : " + entry.getValue());k
}
in map 
the key should be unique
the values should be duplicated

//LinkedList

Queue<String> students = new LinkedList<>();
   student.add("alice");
   student.add("B");
   student.add("c");
   student.add("d");
System.out.println("current" students.poll)
System.out.println("next" students.peack)

comparator and comparable?

The Comparator interface in Java is used to define a custom comparison logic for objects. It allows you to create multiple ways to compare objects, which is particularly useful when you need to sort objects in different ways.
impement compaarator interface and override comparator method 

Comparable interface in Java is used to define the natural ordering of objects of a class. It imposes a total ordering on the objects of each class that implements it. This ordering is referred to as the class’s natural ordering, and the class’s compareTo method is referred to as its natural comparison method1
implements Comparable & @Override
    public int compareTo
returns a negative integer, zero, or a positive integer


10.describe checked and unchekced exception?

      Exception in java - are issues that arise during progm executino which distrupt the normal
                          flow of the application
      types of exception
      
      a.checked exception - some predefined declared in java libraries eg arrayoutofIndex expceiton etc...
            that must be handled at compile time, as they represent predicitabe issues
      b.unchecked exception - it is not officlay declared in java libraries
            occurs at run time, dosen't require explicit handling,often arising from
            logical errors or unexpceted conditions

11.how do you create a custom Exception in java?

      class InvalidAgeException extends Exception{
            public InvalidAgeException(String message){
                  super(message);
            }
      }
      public class A{
         public static void checkAge(int age) throws InvalidAgeException{
               if(age<15 || age > 30 ) throw new
               invalidAgeException(age + "is not allowed sorry!")
               else System.out.println("alway wlcm")
         }
      }
      public static void main(String[] args){
         try{
            checkAge(10);
         }catch(invalidAgeException e)
            e.printStackTrace();
      }
THREAD interview questions:::




12.explain try catch and finally block?
   try block- the code that might throws an arror is kept inside the try block
   catch block- for handling the exceptions
   finally block- it executes regardless whateve happn in try-catch it execute anyways

13.describe == and .equlas() in java?

         string a = new String("hello"); //point to a memory location
         String b = new String("hello"); //point to a memory location
         System.out.println(a==b); //false
      even thought the content is same but a and b point to differnt-
            -memory location so techincally it's different
            System.out.println(a.equals(b));
      
      but for other primitive data types
         int a=10;
         int b=10;
         system.out.println(a==b); it is true 
      
      so Equality operator (==)
         check two refernce variable point to the same memory location
      
      for .equals()
         it will check if two objects have the same data. specific for strings

14.Describe java memory model and how memory is allocated?

in java memory is allocated in two types
   a.Heap - 
      large memory space used for storing object, instance, varible and class variables
      objects that are no longer available or recheable are managed by jvm'S garbage collector
   b.Stack
      each thread in java has its own stack memory.
      Stack memory is generally limited and temporary.

15.hOW MEMORY IS ALLOCATEDD?
   1. object creation: the jvm first determine the size of the object based on its fields.
   2. heap allocation: then jvm allocated a stack of memory from the heap.
   3. initialization: the ojects fields are initialized to their default values.
   4. Reference assignment: a reference is the newly created obj is assigned to a variable
   5.Garbage collection: it periodically scan the heap for objects that are no longer
                        recheable by any active threads

16.HOW DOES GARBAGE COLLECTION WORK IN JAVA?
      It is the automated process that frees up memory by removing objects that are no longer
   in use or is being accessible by the program
   1.AUTOMATIC MEMORY MANAGEMENT: garbage collectors which operates inside the Jvm MANAGES garbage
                                 collection
   2.HEAP MEMORY: as long as oject is referenced by other objects or variable, it remains active
   3.MARK & SWEEP PROCESS: MARK marks the objects as "in use" which is actively referenced.
                           unmarked objects are eventully deleted.

17.WHAT IS LAMBDA EXPRESSION AND HOW IT IS USED IN JAVA?

      it is a consious way to represent an anonymous function
      Syntax: (parameters)-> expression
      (int a ,int b)-> a+b
      
      public static void main(String[] args){
         new Thread(new Runnable(){
         @Override
         public void run(){
            System.out.println("Thread is running")
         }
         }).start();
      
      //using lambda
      new Thread(()-> Ssytem.out.println("Thread is running")).start();
      }
-------------------------------------------------
18.EXPLAIN THE IMPORTANCE OF SYNCHRONIZED KEYWORD?

      Ensures that only one thread can access the synchronized session of the code
      at a time, blocking other threads until the lock is released.
      for eg:
      deadlock..

class counter{
   //if ? a global variable ie anybody can access it right??
      so here synchornized help us

      private int count = 0;
      public synchronized void increment(){
         count++;
      }
      public int getCount(){
         return count++;
      }
}   
public class demo{
   public static void main(String[] args){
         Counter counter = new Counter();
         //creating  a new thred

         Thread t1= new Thread(()->{
            for(int i=0; i< 100: i++){
               counter.increment();
            }                     
         });
//thread 2
         Thread t2= new Thread(()->{
            for(int i=0; i< 100: i++){
               counter.increment();
            }                     
         });
t1.start();  // we start the thread
t2.start();

try{
   t1.join();
}catch(Exception e){
      e.printStackTrace();
}

try{
   t2.join();
}catch(Exception e){
      e.printStackTrace();
}
Syste.out.println(counter.getCount());  
// multipel thread increases counter twice so parallel
//we used snchornized should be 200
   }
}
-------------------------------------
19.EXPALIN THE VOLATILE KEYWORD IN JAVA?

    when the varilable is marked as volatile, cjhanges made to the variable by 
   one thread are immiediatly visible to other threads
   volatile also ensures that the varlues of the variable is always fetced
   from the main memory and not from the thread local cahce

main memory - means heap memory
stack memory - is temporary .
--------------Example
class Counter{
   private Volatile boolean flag = false;
   public void toggleFlag(){
      flag = !flag;
   }
   public boolean getFlag(){
      return flag;
   }
}
public class demo{
   public static void main(String[] args){
      Counter couner = new Counter();
      Thread t1= new Thread(()->{
         counter.toggleFlag();
         System.out.println("Thread 01: Flag toggled to " + counter.getFlag());
      });
   }
}

----------------------------------------------
20.WHAT ARE STREAMS IN JAVA AND HOW ARE THEY USED?

         streams in java is a pipeline that makes it easier to filter, tranform &
         collect data from collections.
         streams can process parallel, achieving multi core processors for performance

For Eg:
public class demo{
   public static void main(String[] args){}
      List<String> names= Arrays.asList("aa","b","ac","d");
      List<String> modifiedList = 
               names.stream().filer(x->x.startsWith("a"))
                     .map(String::toUpperCase)
                     .collect(Collectors.toList());
      modifiedList.forEach(System.out::println);
}

21.WHAT ARE JAVA ANNOTATION AND HOW DO THEY WORK?

   the metadata tags added to code elements like classes, method & fields
to provide additional information.l
eg @Override
@Depreciated - 
@SuppresWarnings("unchecked" rawtypes etc...)- to avoid unnecessary waring
@FunctionalInterface- only one method should be there in an interface

22.AUTOBOXIG AND UNBOXING
   AUTOBOXING: the automatic conversion of primitive types into
               corresponding wrapper class (eg int to Integer)
   UNBOXING: converts an object of a wrapper classs back into its
               corresponding primitive class

eg int num=5;
   Integer numOjbect = num;  

   System.out.println(num)    //5
   System.out.println(numOjbect) //5
   System.out.println(numOjbect.getClass()); /class java.lang.Integer


23. WHAT IS THE PURPOSE OF TRANSIETN KEYWORD IN SERIALIZATION?
         serialization is the process of converting an objects state into
      a byte stream, allowing it to be saved to a file, sent over a n/w, etc.

eg serailaiztino    || a|| ---> ||b||  here data being transfered by broken down into small perice 

Transietn keyword
 tellls the jvm to ignore a field when serializing an object


for eg

      class user implements Serializable{  // which means it can be broken down
            private String username;
            private transient String passoword; // which cannot be broken down so 
                                             // we are using transient 
      public user(String username, String passord){}
            this.userame= username;
            ..
      }
--------------------------------------------------------
24.WHAT IS THE DIFFERENCE BETWN STRING AND STRINGBUILDER?

      String- once a sting object is created, its values cannot be changed
              ie immutable one
               also when you try to modify a String a completly new obj is create that the 
                drawback of String
     
      StringBuilder- value can change the values of the object after it's created 
                        ie mutable one

      String name= "Akil";
      Ssytem.out.println(name);
      name = name+ "is a goodboy";
      System.out.println(name); here concatend and new object is created!!\

      StringBuilder sb = new StringBuilder("Hello");
      sb.append("workd"); // here no new object is created we are jsut modify existing


------------------------------------
 25.why pointer is not used in java
 
       we know jvm is responsbile for memory allocation in java,
      to stop direct access to memory in java pointer is discourged
       and they are unsafe
 
 26.what is jit compiler?

---------concluseion------------
      so jdk is for developer to create java applications
      jre is for used to run java application
      
       from --scr code to (jdk for conversion) --byte code
       from --byte code to (jvm for conversion (insidee jvm we have[jit compiler and interpreter])) --machine code
      
      jdk--java development kit that provide all the tools required to
       develop,complile and run the java app
       jdk we have
       compiler - 
       debugger
       jre - bunch of libraries
      
      jvm- java virtual machine
       key component - memory management = allo/deallo memory for the applcation
       -garbage collection = automatically  cleans up unused memory
       -security = 

27.what are access modifier?

     a. public - if a class, method or variable is public is can be access anywhere
     b. private - elements is accessible within the class 
     c. protected- accessible within same package and by sub class
               use this when you want to give access to the sub class, even they are ins
                  differnet package
      d.default - when nothing is specifed java applies default
            no modifier when you want to limit access to class within the same package
            but keep members hidden from classes in other package

 28.what is marker interface?
 
       an interface which has no data member and member fucntions 
      simply an empty interface eg serializable , cloneable etc
      then why dont we have it, means it tells the compiler that someting to do with it
      particular thing to do to for jdk and compiler

 hint ctrl shift t
 public interfcae Cloneable{
 }

28. can we override private or static method in java??

      we cannot overrid private method- we can only create another private method
      with same name in the child class 
If you define a method in a subclass with the same signature as a private method in the superclass, 
it's considered a completely new method in the subclass.

      no u cannot ovveride static method
      for static method if you override then it will hide the supercalss method
      known as method hidding...

eg
class Animal{
      public static void sound(){
                  "woff-woof";
      }
}
class Dog extends Animal{
public static void sound(){
                  "whooo";
      }
}
public class Main{
      public static void main(String[] args){
            Animal .sound(); //woff-wooff
            Dog.sound(); //whoo
      }
}

29. Does finally always execute in java?

      not in the following case
      jvm can teminatin when we used 
      1. "System.exit()" function  when we call it explicitally
      2. system crash

      try{
            System.out.println("inside a");
            System.exit(0);// this will terminate the jvm
      }finally{
            System.out.println("not get printed")
      }

30. what method does object class have?

      clone()
      equals()
      finalize()
      hashcode() return hascode value for the oject
      getClass()
-----------------------------------------------------------------------
31.what is singleton class in java? how can we make a class singleton??
      
      1st make sure make your Contructor as private to make sure nobody can create any
      then to create one oject, we have to crearte one      
      2nd,  public static Animal single_instance= null;      
      3rd we have to create a static block for the same which will return the same class oject
           
only one instance is created at any givenn time in one JVM
EG:
            public class Animal{
      // Step 2: Create a private static instance of the class
            private static Animal single_instance = null;
      // Step 1: Make the constructor private
            private Animal(){
            }
       // Step 3: Provide a public static method to get the instance
            public static Animal getIntance(){
             if(single_instance ==null)
               single_instance = new Animal();
                  }
             return single_insatnce;
            }
-------------------------------------------------
32.is java is pass by value or pass by reference??

java is pass by value
      pass by value-- sending memory address of the value
      pass by reference-- reather than passing real memory address, 
                           it send the copy in another mem location

TCS interview questions
33.Explain the concept of object cloning and how it is used in Java?

shallow copy: by default clone method did shallow copy
      just copy the object field as they are
      if obj contain reference to other obj only ref are copied not the actu obj

Deep Copy:
      actual objcet are also copied 
      you need to overrrid clone() method and manually clone the referenced obj
for EG" 
class person implements Cloneable{
      int age;
      String name;

@override
protected object clone() throws CloneNotFoundException{
      return super.clone();
}
}
public class Main{
      public static void main(String[] args){
            try{
                  person p1 = new person(21,"xxx");
                  person p2 = (person)p1.clone()
            }catch(CloneNotFoundException e)
                  e.printStackTrace();
      }
}

Threads? in Java

Extending a thread class or by implementing the runnable interface

class MyThread extends Thread {
    public void run() {
        // Code to be executed by the thread }}
MyThread thread = new MyThread();
thread.start();

or by implementing Runnable interface!!

class MyRunnable implements Runnable{
      Public void run(){
      //code to be 
      }
}
Thread t = new Thread(new MyRunnable());
t.start();

Synchronization!!
      when multiple thread access shared resources. synchorniztion in
      necessarry to prevent data inconsitency 
      to ensure only one thread can access a resource at a time.

--LifeCycle of thread?--
new> runnable> running> (blocked/waiting/time waiting) > terminated

start() method: moves the thread from new state to runnable
sleep() method: Temporarly pass the thread, moving it to timed waiting
wait() method: moves the thread to waiting until another thread calls
                  notify() or notifyAll()
 notify() or notifyAll(): wakes up the single or all
                        threads that are waiting on the object monitors
join(): waits for the thread to die, moving it to the waiting state

NEW state: 
      when it is created but not yet started
Thread th = new Thread();

RUNNABLLE state: 
      after start() method is called the Thread moves to the runnable state
      it is ready to run and waiting for the cpu time.
th.start();

RUNNING state:
      when the thread schedler select the thread, it moves to the
      running state and starts executing its run() method
public void run(){
//code to be executed by the thread
}
BLOCKED/WAITING :
      when it is waiting for a resource or another thread to perform
      a particular action
      BLOCKED:waiting for monitor lock
      WAITING:for another thread to perform a specific actions

synchronized (object){
      object.wait();//waiting state
}
TERMINATED state:
once completed the execution it is explicitly terminated



34.What is the difference between an abstract class and an interface in Java?

abstract class 
      can have both abstract and concret method
      support single inheritance, a class can inherit only one abstract class
      can have final, non final, non sttic variable

eg:
abstract class Animal{
      abstract void makeSound();
      void eat(){
            System.out.println("eating");
      }

}
interface:
      have only abstract method until java7
      after java 8 can also have default and static method
      from java 9 can have private method as well
      we need to used defualt keyword 
      variable by default: static and final
      access modifier public by default
 EG:
      interface vehicle{
            void start();
            default void stop(){
                    Ssytem.out.println("stopped");
            }
      }
35.What is a deadlock, and how do you avoid it?
????

36.What is the difference between an object-oriented programming language and 
an object-based programming language?

oops: java c++ c# then python 
object based pL : java script have built in object & class

37.How do you implement a binary search in Java?>
binary search algorith for finding an item form a sorted list of items

      public class BinarySearch {
            public static void main(String[] args){
            int[] array={1,2,3,4,5};
            int target = 10;
            int result = Arrays.binarySearch(array,target);
      
            if(result <0){
                  Ssytem.out.println("element not found");
            }else
                  System.out.println("foud");
            }
      }

----Design pattern in java---- there are around 23 design pattern

i.Singleton Design pattern in java 

31.what is singleton class in java? how can we make a class singleton??
      
      when we need one object to control things in the whole system
      1st make sure make your Contructor as private to make sure nobody can create any
      then to create one oject, we have to crearte one      
      2nd,  public static Animal single_instance= null;      
      3rd we have to create a static block for the same which will return the same class oject
           
only one instance is created at any givenn time in one JVM
EG:
            public class Animal{
      // Step 2: Create a private static instance of the class
            private static Animal single_instance = null;
      // Step 1: Make the constructor private
                 so no other class can instantiate it
            private Animal(){
            }
       // Step 3: Provide a public static method that returns the
                  instance of the class
            public static Animal getIntance(){
             if(single_instance ==null)
               single_instance = new Animal();
                  }
             return single_insatnce;
            }
-------------------------------------------------------------
2/7/2024

1.CREATIONAL DESIGN PATTERN :
responsible for create object/controls the creations of objects

A.PROTOTYPE PATTERN:
      used when we have to make copy/clone from existig object.

for Eg; hint: how you can do clone of an object
             for a private instance variable also consider a situation
where you have 100 of inst variable how come your clone object know which are all
need to worrie about what are client need to  leaved and copied?

public class Students{
      int age;
      private int rollNumber;
      String name;

      Student(){
      }
Student(int age, int rollNumber, String name){
      this.age = age;
      this.rollNumber = rollNumber;
      this.name= name;
`  }
}
public class Main {
      public static void main(String[] args){
//orginal object
      Student obj = new Student(20,112,"akil");
//creating clone of object 
      Student cloneObj = new Student();
      cloneObj.name = obj.name;
      cloneObj.age = obj.age;
// the problem is rollNumber is private 
      cloneObj.rollNumber = obj.rollNumber; 
      }
}

solution: 

create one prototype <<Interface>> clone() & all the class implement
the interface & implement clone() method.

EG: 
public interface Prototype {
      Prototype clone();
}

public class Students implements Prototype{

      int age;
      private int rollNumber;
      String name;

      Student(){
      }
Student(int age, int rollNumber, String name){
      this.age = age;
      this.rollNumber = rollNumber;
      this.name= name;
`  }

@Override
public Prototype clone() {
//create a new student obj with all my properties!!
      return new Student(age,rollNumber,name);
}

public class Main {
      public static void main(String[] args){
            Student obj = new Student(20, 75, "Ram");
//now cloning!
            Student cloneObj = (Student) obj.clone();
      }
}
-------------------------------------------------
2.SINGLETON PATTERN
      it is used when we have to create only 1 instance of the class.
four ways to achieve this.
      1.eager initialization
      2.lazy 
      3. Synchronized Method & 
      4.Double Locking (used in the industry)

1. you have to restrict the creation of object
   creating the constructr as private
2.expose one method which other class can call it
  ie static method- so call it thorugh class name

Eager initialization: simply called load time initialization!!
            public class DBConnection {
            //eager initializtino in the instance variable as static
            and eagerly insitilized it!!
            //when the class will load this static obj get also intitilized
            
                  private static DBConnection conObject = new DBConnection();
            //creating the constructr as private
                  private DBConnection(){
                  }
            //this method ruturn makure sure only one obj is created
                  private static DBConnection getInstance(){
                        return conObject;
                  }
            }
            public class main {
                  public static void main(String[] args){
                  DBConnection connObject = DBConnection.getInstance();
                  }
            }

2.Lazy initialization:

public class DBConnection {
      private static DBConnection conObject = null;      
      private DBConnection(){
      }
      public static DBConection getInstance(){
            if(conObject == null){
                  conObject = new DBConnection();
            }
            return conObject;
      }
}
what if 2 thread comes simulatencoly so both will find conObject is null!!!
so two object is created so there is a problem in lazy initialization

3.Synchronized Method:

public class DBConnection {
      private static DBConnection conObject = null;      
      private DBConnection(){
      }
// Synchronized will put a lock
wait for one thread to create new object next !!!
     Synchronized public static DBConection getInstance(){
            if(conObject == null){
                  conObject = new DBConnection();
            }
            return conObject;
      }
}
problem in synchronized is first time it will put a lock
then next time. do the rest

d.Double Locking: 

public class DBConnection {
      private static DBConnection conObject = null;      
      private DBConnection(){
      }

      public static DBConection getInstance(){
//two time check things
//
            if(conObject == null){
//puting a lock
                  Synchronized(DBConnection.class){
                  if(conObject == null){
                        conObject = new DBConnection();
                  }
            }
            return conObject;
      }
}
-------------------------------
      FACTORY PATTERN:

used when all object creation and it's business logic we need to
keep it  at one place.

For EG:

public interface Shape {
      public void computerArea();
}

public class Square implements Shape{
      @Override
      public void computeArea(){
            System.out.println("Compute square area")
      }
}

public class Circle implements Shape{
      @Override
      public void computeArea(){
            System.out.println("Compute Circle area")
      }
}
//if in furture any change is required i can modfy here itslef
ie for only one class for change
public class ShapeInstanceFactory {
      public Shape getShapeInstance(String value){
//responsible for creating the object
      if(value.equals("Circle")){
            return new Circle();
      }
      else if(value.equals("Square")){
            return new Square();
      }
      else if(value.equals("Rectangle")){
            return new Rectange();
      }
      return null;
      }
}

public class Main {
      public static void main(String[] args){
            ShapeInstanceFactory factoryObj = new ShapeInstanceFactory();
            Shape circleObj = factoryObj.getShapeInstance("Circle");
            circleObj.computeArea();
      }
}

-------------------------------
     ABSTRACT FACTORY PATTERN:

it is a factory or factory.
eg differennt variety of 
      car> ecnonmy car1|ecnonmy car2|ecnonmy car3
           luxury car1| luxury car2 | luxury car3

for EG:

public interface Car{
      public int getTopSpeed();
}
//abstract factory
public interface AbstractFacory{
      public Car getInstance(int price);
}
public class EcnonmicCar1 implements Car{
      @Override
      pubilc int getTopSpeed(){
      return 100;
      }
}
public class EcnonmicCar2 implements Car{
      @Override
      pubilc int getTopSpeed(){
      return 150;
      }
}
 public class Luxurycar01 implements Car{
      @Override
      pubilc int getTopSpeed(){
      return 150;
      }
}
public class Luxurycar02 implements Car{
      @Override
      pubilc int getTopSpeed(){
      return 250;
      }
}

//created two factory class

public class EconomicCarFactory implements AbstractFacory{
      @Override
      public Car getInstance(int price){
      if(price <=300000){
            return new EconomicCar1();
      }else if(price <=300000){
            return new EconomicCar1();
      }
      return null;
      }
}

public class LuxuryCarFactory implements AbstractFacory{
      @Override
      public Car getInstance(int price){
      if(price <=300000){
            return new EconomicCar1();
      }else if(price <=300000){
            return new EconomicCar1();
      }
      return null;
      }
}

//returning economic or luxury factory 
public class AbstractFactoryProducer {
      public AbstractFacory getFactoryInstance(String value){
      if(value.equals("Economic")){
            return new EcnonoicCarFactory();
      }else if(value.equals("Economic")){
            return new EcnonoicCarFactory();
      }return null;
}

public clas Main {
      public static void main(String args[]){
      AbstractFactoryProducer afpob = new AbstractFactoryProducer();
      AbstractFactory afo = afpob.getFactoryInstance("Premium");
      car carObj = abstractFactory.getInstance(5000);
      System.out.pritln(carObj.getTopSpeed());
      }
}

-------------------------------
   BUILDER PATTERN:
When you want to create Object step by step

public class Student{
      int rollno;
      int age;
      String name;
      String fathername;
      //constructo
      //toString
}
this has the implementation of all the steps
public abstract class StudentBuilder{
      int rollno;
      int age;
      String name;
      String fathername;
set the properties
abstract public StudentBuilder setSubject();
public Student build() {
      return new Student(Builder this);
}
}
from the builder it will create the final product
}
