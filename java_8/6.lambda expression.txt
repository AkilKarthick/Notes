lambda expression:
------------------

for cleaner code | better readability | less boiler plate code
a concise way to represent an anonymous function (a function without function name) 
that can be passed as an arugument to methods or .used for functional style programming
lambda expression provide implementaqtion logic for functional interface (interface wiht only one abstract method)

suppose if you have some prodct that you need to sort in asc/dec order 
before java 8, you have to create a class for comparing the produce like below

public class ProductCompareAscendingOrd implements Comparable<String> {
@Override
public int compare(String o1, String o2){
	return o1.compareTO(02);

here the problem is if you need to sort in descding order mean you need to crete another class for that, so bulky code and you can use annonymous class for this tht too get a certical problem with bulky syntax
	List<String> p1 = Arrays.asList();
p1.sort(new ProductCompareAscendingOrd);

or 

p1.sort(new ProductCompareAscendingOrd() {
	public int compare(String 01,string 02)
		return o1.compareTo(o2);
});

so using lambda is the good way to reduce the lines of code

p1.sort((s1,s2) -> s1.compartTo(s2));
or
p1.sort((s1,s2) -> {return s2.compareTo(s1)})
hints:

A lambda expression is an anonymous function that provides a clear and concise way to implement the abstract method of a functional interface
An interface with exactly one abstract method. Lambda expressions can only be used to implement functional interfaces.
They reduce boilerplate code by eliminating the need for anonymous inner classes
------
syntax
(parameters) -> expression

it simplifies code by allowing single method interface(functional interface) to be implemented directly, without creating a separate class

eg:

sigle parameter:
(x) -> x * x

multiple parameter:
(a,b) -> a +b

Block expression:
(x,y) -> {
	int sum = x + y;
	return sum;
	}


list iteration:

List<string> list = Arrays.asList("a","b","c");
list.forEach(item ->System.out.println(item) )

=========================
Functional Interfaces::

having one abstract method, and allowded to have any number of static/default method
lambda expression can appread only in place where functinal interface are used

@FunctionalInterface
interface Operation{
	int process(int a, int b); // only abstract method
	}

Operation addition = (a,b) -> a +b;
System.out.println(addition.process(1,2);


=======================================
method reference for lambda expression:

for EG:

class employee{ // empid, empname & country attributes
	public static int compareByCountry(employee e1, employe e2){
	   	return e1.getCountry().compareTo(e2.getCountry());

//using lambda 
empList.sort( (e1,e2)->employee.compareByCountry(e1,e2));

//using method reference

empList.sort(employee::compareByCountry);// easy to read maekre expression compact and easy to read


predefined funcational interface
================================


Function = we have apply() abstract method 
	that acceps a single arguments and produces result
Predicate = boolean test() method take single argument
Consumer = void accpet() , accept single arguments but return no result
Supplier = get() , denote a supplier of results

for EG:

we have a method 
public static double computeSalary(Employee e, Function<Employee, Double> fn) {
return fn.apploy(e);

---------
Traversing collections using lambda
------------------------------------

for(Employee e: elist){
Sysout(e.getCountry();
}

here using lambda don t need to creaqte iteraor, loopiong throgh it and checking for more elements

just

elist.forEach(s->Sysout(s.getCountry()));

-----
üéØ Interview questions on Lambda expressions: dont expect straight frwd questions

1.how lambda work internally?

lambda donot create a new class file like annonymous class
they invokedynamic and are resolved at runtime

less memory overhead
better performacnce
enable JVm optimization



1.Why lambdas need functional interfaces?

2.Can lambda access local variables?

	yes but they must be effectively final (value cannot be changed after initialization)
	
	String msg = "hello";
	Runnable r =()->System.out.println(msg); //msg must be effectively final
	
	//compilation error 
	
	int threshold =5;
	list.forEach(i->{
			System.out.println(i>threahso);
	})

3.difference btwn Lambda VS Annonymous Inner class?

this keyword:  in lambda refers to enclosing class
			   in annonymouc casl it refer to inner class
performnace:  lambda is beeter, annonymous inner class is slightly heaviour

4. why lambda expression introuduced in java8?

to support functional style programming
reduce boiler plate code
enable paraller & declarative processing through the stream API.
lambda enable declarative style


common builtin functional interface
| Interface     | Method    | Real Project Usage   |
| ------------- | --------- | -------------------- |
| Predicate<T>  | test(T)   | Filtering DB results |
| Function<T,R> | apply(T)  | DTO mapping          |
| Consumer<T>   | accept(T) | Logging, audit       |
| Supplier<T>   | get()     | Lazy object creation |


Predicate<User> activeUser = u->u.isActive();
users.stream().filter(activeUser).toList();

5. can lambda through checked exception? (TRICKY ‚ö†Ô∏è)

‚ùå No directly
list.forEach(i->{
	throus new IOException();   ‚ùå
});

then how to handle checked Exception?

lambda wrapper for lamda function, for handling the expcetion
an
dont know the implementation part!!
	wrap in runtime exception
	use cutsom functional interface
	handle inside lambda

6. lambda & this keyword?

in lambda, this refer to the instance of the enclosing class, not lambda itslef

	public class LambdaThisExample {
	    String name = "OuterClass";
	
	    public void testLambda() {
	        MyPrinter printer = () -> {
	            System.out.println(this.name); // Refers to LambdaThisExample's 'name'

this is in Anonymous inner class:

refer to the instance of the annonymous class itself, not the enclosin class
------------------------------

Final Interview-Ready Summary (Say This üî•)
In real projects, I use lambda expressions mainly with Streams, Comparators, and functional interfaces to write clean, readable, and maintainable code. I avoid complex logic inside lambdas and always consider readability and debugging impact.‚Äù

Performance Consideration (Senior-level)

	lambd are light weight
	avoid heavy logic inside streams
	don't misuse paralle streams blindly



